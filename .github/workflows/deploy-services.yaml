name: Deploy Services

on:
  workflow_dispatch:
    inputs:
      image_tag:
        description: "Image tag to deploy (default: latest)"
        required: false
        default: "latest"
  workflow_run:
    workflows: ["Build Services"]
    types:
      - completed
    branches:
      - main

env:
  REGISTRY: ghcr.io
  IMAGE_PREFIX: ${{ github.repository_owner }}/vomeet
  NAMESPACE: vomeet

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: production
    # Only run if workflow_dispatch OR if build succeeded
    if: >
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success')

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set image tag
        id: tag
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "tag=${{ inputs.image_tag }}" >> $GITHUB_OUTPUT
          else
            # For workflow_run, use latest
            echo "tag=latest" >> $GITHUB_OUTPUT
          fi

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Check if images exist
        env:
          TAG: ${{ steps.tag.outputs.tag }}
        run: |
          SERVICES="admin-api api-gateway bot-manager transcription-collector"
          MISSING=""
          for svc in $SERVICES; do
            IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-${svc}:${TAG}"
            if ! docker manifest inspect "$IMAGE" > /dev/null 2>&1; then
              MISSING="${MISSING}${svc} "
            fi
          done
          if [ -n "$MISSING" ]; then
            echo "âŒ Missing images for tag ${TAG}: ${MISSING}"
            exit 1
          fi
          echo "âœ… All images exist for tag ${TAG}"

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'v1.32.2'

      - name: Setup Helm
        uses: azure/setup-helm@v4
        with:
          version: '3.16.4'

      - name: Create kubeconfig
        run: |
          mkdir -p ~/.kube
          cat > ~/.kube/config << EOF
          apiVersion: v1
          kind: Config
          clusters:
            - name: ${{ vars.KUBE_CLUSTER_NAME_PROD }}
              cluster:
                server: ${{ vars.KUBE_CLUSTER_URL_PROD }}
                certificate-authority-data: ${{ secrets.KUBE_CERTIFICATE_PROD }}
          contexts:
            - name: ${{ vars.KUBE_CLUSTER_NAME_PROD }}
              context:
                cluster: ${{ vars.KUBE_CLUSTER_NAME_PROD }}
                namespace: ${{ env.NAMESPACE }}
                user: vomeet-admin
          users:
            - name: vomeet-admin
              user:
                token: ${{ secrets.KUBE_TOKEN_PROD }}
          current-context: ${{ vars.KUBE_CLUSTER_NAME_PROD }}
          EOF
          chmod 600 ~/.kube/config

      - name: Update Helm dependencies
        run: |
          helm dependency update ./chart

      - name: Create namespace
        run: |
          kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy Helm chart
        env:
          TAG: ${{ steps.tag.outputs.tag }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          ADMIN_API_TOKEN: ${{ secrets.ADMIN_API_TOKEN }}
        run: |
          helm upgrade --install vomeet ./chart \
            --namespace ${{ env.NAMESPACE }} \
            --set global.imageTag="$TAG" \
            --set postgresql.password="$DB_PASSWORD" \
            --set adminApiToken="$ADMIN_API_TOKEN" \
            --set httpRoute.enabled=true \
            --set "httpRoute.hostnames[0]=vomeet.voltade.com" \
            --set "httpRoute.hostnames[1]=vomeet.io" \
            --set "httpRoute.parentRefs[0].name=cloudflare-https" \
            --set "httpRoute.parentRefs[0].namespace=gateway" \
            --wait \
            --timeout 10m

      - name: Force rollout restart
        run: |
          echo "ðŸ”„ Forcing rollout restart for all deployments..."
          kubectl rollout restart deployment/vomeet-admin-api -n ${{ env.NAMESPACE }}
          kubectl rollout restart deployment/vomeet-api-gateway -n ${{ env.NAMESPACE }}
          kubectl rollout restart deployment/vomeet-bot-manager -n ${{ env.NAMESPACE }}
          kubectl rollout restart deployment/vomeet-transcription-collector -n ${{ env.NAMESPACE }}
          
          echo "â³ Waiting for rollouts to complete..."
          kubectl rollout status deployment/vomeet-admin-api -n ${{ env.NAMESPACE }} --timeout=120s
          kubectl rollout status deployment/vomeet-api-gateway -n ${{ env.NAMESPACE }} --timeout=120s
          kubectl rollout status deployment/vomeet-bot-manager -n ${{ env.NAMESPACE }} --timeout=120s
          kubectl rollout status deployment/vomeet-transcription-collector -n ${{ env.NAMESPACE }} --timeout=120s
          echo "âœ… All rollouts complete!"

      - name: Run database migrations
        env:
          TAG: ${{ steps.tag.outputs.tag }}
        run: |
          echo "ðŸ”„ Running database migrations..."
          
          # Wait for CNPG cluster to be ready
          echo "Waiting for CNPG cluster..."
          kubectl wait --for=condition=Ready cluster/vomeet-cnpg -n ${{ env.NAMESPACE }} --timeout=120s || true
          
          # Delete any previous migration job
          kubectl delete job db-migrate -n ${{ env.NAMESPACE }} --ignore-not-found=true
          
          # Create migration job
          cat <<EOF | kubectl apply -f -
          apiVersion: batch/v1
          kind: Job
          metadata:
            name: db-migrate
            namespace: ${{ env.NAMESPACE }}
          spec:
            ttlSecondsAfterFinished: 300
            backoffLimit: 3
            template:
              spec:
                restartPolicy: Never
                containers:
                - name: migrate
                  image: ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-transcription-collector:${TAG}
                  command:
                  - sh
                  - -c
                  - |
                    set -e
                    echo "Checking database state..."
                    
                    # Check if alembic_version table exists (using sync engine)
                    if python -c "
                    from sqlalchemy import text
                    from shared_models.database import get_engine
                    def check():
                        engine = get_engine()
                        with engine.connect() as conn:
                            result = conn.execute(text(\"SELECT 1 FROM information_schema.tables WHERE table_name='alembic_version'\"))
                            return result.scalar() is not None
                    print('EXISTS' if check() else 'EMPTY')
                    " | grep -q "EXISTS"; then
                      echo "Database is Alembic-managed, running upgrade..."
                      alembic -c /app/alembic.ini upgrade head
                    else
                      echo "Fresh database, initializing schema..."
                      python -c "import asyncio; from shared_models.database import init_db; asyncio.run(init_db())"
                      alembic -c /app/alembic.ini stamp head
                    fi
                    echo "âœ… Migration complete!"
                  env:
                  - name: DB_HOST
                    value: vomeet-cnpg-rw
                  - name: DB_PORT
                    value: "5432"
                  - name: DB_NAME
                    value: vomeet
                  - name: DB_USER
                    value: vomeet
                  - name: DB_PASSWORD
                    valueFrom:
                      secretKeyRef:
                        name: vomeet-db
                        key: password
                  - name: REDIS_HOST
                    value: dragonfly
                  - name: REDIS_PORT
                    value: "6379"
          EOF
          
          # Wait for job to complete
          echo "Waiting for migration job to complete..."
          kubectl wait --for=condition=complete job/db-migrate -n ${{ env.NAMESPACE }} --timeout=120s
          
          # Show logs
          echo "Migration logs:"
          kubectl logs job/db-migrate -n ${{ env.NAMESPACE }}
          
          echo "âœ… Database migrations complete!"

      - name: Verify deployment
        run: |
          echo "Checking deployments..."
          kubectl get deployments -n ${{ env.NAMESPACE }}
          echo ""
          echo "Checking pods..."
          kubectl get pods -n ${{ env.NAMESPACE }}
          echo "âœ… Deployment verified"

      - name: Cleanup kubeconfig
        if: always()
        run: rm -f ~/.kube/config

      - name: Send success notification to Telegram
        if: success()
        env:
          TAG: ${{ steps.tag.outputs.tag }}
        run: |
          curl -s -X POST "https://api.telegram.org/bot${{ secrets.TELEGRAM_BOT_TOKEN }}/sendMessage" \
            -d chat_id="${{ secrets.TELEGRAM_CHAT_ID }}" \
            -d message_thread_id="${{ secrets.TELEGRAM_THREAD_ID }}" \
            -d text="âœ… *Vomeet Deployed*%0A%0AðŸ“¦ Services: all%0AðŸ·ï¸ Image Tag: ${{ env.TAG }}%0AðŸ‘¤ Triggered by: ${{ github.actor }}%0Aâ° Time: $(date -u '+%Y-%m-%d %H:%M:%S UTC')%0AðŸ”— [View Run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})" \
            -d parse_mode="Markdown"

      - name: Send failure notification to Telegram
        if: failure()
        env:
          TAG: ${{ steps.tag.outputs.tag }}
        run: |
          curl -s -X POST "https://api.telegram.org/bot${{ secrets.TELEGRAM_BOT_TOKEN }}/sendMessage" \
            -d chat_id="${{ secrets.TELEGRAM_CHAT_ID }}" \
            -d message_thread_id="${{ secrets.TELEGRAM_THREAD_ID }}" \
            -d text="âŒ *Vomeet Deploy Failed*%0A%0AðŸ·ï¸ Image Tag: ${{ env.TAG }}%0AðŸ‘¤ Triggered by: ${{ github.actor }}%0Aâ° Time: $(date -u '+%Y-%m-%d %H:%M:%S UTC')%0AðŸ”— [View Run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})" \
            -d parse_mode="Markdown"
