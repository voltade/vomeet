name: Deploy Services

on:
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment to deploy to"
        required: true
        type: choice
        options:
          - production
          - staging
        default: production
      image_tag:
        description: "Image tag to deploy (default: latest for prod, staging for staging)"
        required: false
        default: ""
  workflow_run:
    workflows: ["Build Services", "Build Services (Staging)"]
    types:
      - completed
    branches:
      - main
      - staging

env:
  REGISTRY: ghcr.io
  IMAGE_PREFIX: ${{ github.repository_owner }}/vomeet

jobs:
  set-environment:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.determine.outputs.environment }}
      namespace: ${{ steps.determine.outputs.namespace }}
      image_tag: ${{ steps.determine.outputs.image_tag }}
    steps:
      - name: Determine environment
        id: determine
        run: |
          # Determine environment
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            ENV="${{ inputs.environment }}"
            TAG="${{ inputs.image_tag }}"
          elif [ "${{ github.event_name }}" == "push" ] && [ "${{ github.ref }}" == "refs/heads/staging" ]; then
            ENV="staging"
            TAG="staging"
          else
            # workflow_run from main branch
            ENV="production"
            TAG="latest"
          fi
          
          # Set default tag if empty
          if [ -z "$TAG" ]; then
            if [ "$ENV" == "staging" ]; then
              TAG="staging"
            else
              TAG="latest"
            fi
          fi
          
          echo "environment=$ENV" >> $GITHUB_OUTPUT
          echo "image_tag=$TAG" >> $GITHUB_OUTPUT
          
          # Set namespace based on environment
          if [ "$ENV" == "staging" ]; then
            echo "namespace=vomeet-staging" >> $GITHUB_OUTPUT
          else
            echo "namespace=vomeet" >> $GITHUB_OUTPUT
          fi

  deploy:
    needs: set-environment
    runs-on: ubuntu-latest
    environment: ${{ needs.set-environment.outputs.environment }}
    # Only run if workflow_dispatch OR if build succeeded
    if: >
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success')

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Check if images exist
        env:
          TAG: ${{ needs.set-environment.outputs.image_tag }}
        run: |
          SERVICES="admin-api api-gateway bot-manager google-integration transcription-collector"
          MISSING=""
          for svc in $SERVICES; do
            IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-${svc}:${TAG}"
            if ! docker manifest inspect "$IMAGE" > /dev/null 2>&1; then
              MISSING="${MISSING}${svc} "
            fi
          done
          
          # Check vomeet-bot separately (different naming)
          BOT_IMAGE="${{ env.REGISTRY }}/${{ github.repository_owner }}/vomeet-bot:${TAG}"
          if ! docker manifest inspect "$BOT_IMAGE" > /dev/null 2>&1; then
            MISSING="${MISSING}vomeet-bot "
          fi
          
          if [ -n "$MISSING" ]; then
            echo "âŒ Missing images for tag ${TAG}: ${MISSING}"
            exit 1
          fi
          echo "âœ… All images exist for tag ${TAG}"

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'v1.32.2'

      - name: Setup Helm
        uses: azure/setup-helm@v4
        with:
          version: '3.16.4'

      - name: Create kubeconfig
        env:
          ENVIRONMENT: ${{ needs.set-environment.outputs.environment }}
        run: |
          # Set environment-specific values
          if [ "$ENVIRONMENT" == "staging" ]; then
            KUBE_CLUSTER_NAME="${{ vars.KUBE_CLUSTER_NAME_STAGING }}"
            KUBE_CLUSTER_URL="${{ vars.KUBE_CLUSTER_URL_STAGING }}"
            KUBE_TOKEN="${{ secrets.KUBE_TOKEN_STAGING }}"
            KUBE_CERT="${{ secrets.KUBE_CERTIFICATE_STAGING }}"
          else
            KUBE_CLUSTER_NAME="${{ vars.KUBE_CLUSTER_NAME_PROD }}"
            KUBE_CLUSTER_URL="${{ vars.KUBE_CLUSTER_URL_PROD }}"
            KUBE_TOKEN="${{ secrets.KUBE_TOKEN_PROD }}"
            KUBE_CERT="${{ secrets.KUBE_CERTIFICATE_PROD }}"
          fi
          
          mkdir -p ~/.kube
          cat > ~/.kube/config << EOF
          apiVersion: v1
          kind: Config
          clusters:
            - name: $KUBE_CLUSTER_NAME
              cluster:
                server: $KUBE_CLUSTER_URL
                certificate-authority-data: $KUBE_CERT
          contexts:
            - name: $KUBE_CLUSTER_NAME
              context:
                cluster: $KUBE_CLUSTER_NAME
                namespace: ${{ needs.set-environment.outputs.namespace }}
                user: vomeet-admin
          users:
            - name: vomeet-admin
              user:
                token: $KUBE_TOKEN
          current-context: $KUBE_CLUSTER_NAME
          EOF
          chmod 600 ~/.kube/config

      - name: Update Helm dependencies
        run: |
          helm dependency update ./chart

      - name: Create namespace
        run: |
          kubectl create namespace ${{ needs.set-environment.outputs.namespace }} --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy Helm chart
        env:
          TAG: ${{ needs.set-environment.outputs.image_tag }}
          NAMESPACE: ${{ needs.set-environment.outputs.namespace }}
          ENVIRONMENT: ${{ needs.set-environment.outputs.environment }}
        run: |
          # Set environment-specific secrets
          if [ "$ENVIRONMENT" == "staging" ]; then
            DB_PASSWORD="${{ secrets.DB_PASSWORD_STAGING }}"
            ADMIN_API_TOKEN="${{ secrets.ADMIN_API_TOKEN_STAGING }}"
            VALUES_FILE="chart/values-staging.yaml"
          else
            DB_PASSWORD="${{ secrets.DB_PASSWORD }}"
            ADMIN_API_TOKEN="${{ secrets.ADMIN_API_TOKEN }}"
            VALUES_FILE="chart/values-production.yaml"
          fi
          
          helm upgrade --install vomeet ./chart \
            --namespace "$NAMESPACE" \
            --values "$VALUES_FILE" \
            --set global.imageTag="$TAG" \
            --set postgresql.password="$DB_PASSWORD" \
            --set adminApiToken="$ADMIN_API_TOKEN" \
            --wait \
            --timeout 10m

      - name: Force rollout restart
        env:
          NAMESPACE: ${{ needs.set-environment.outputs.namespace }}
        run: |
          echo "ðŸ”„ Forcing rollout restart for all deployments..."
          kubectl rollout restart deployment/vomeet-admin-api -n "$NAMESPACE"
          kubectl rollout restart deployment/vomeet-api-gateway -n "$NAMESPACE"
          kubectl rollout restart deployment/vomeet-bot-manager -n "$NAMESPACE"
          kubectl rollout restart deployment/vomeet-google-integration -n "$NAMESPACE"
          kubectl rollout restart deployment/vomeet-google-integration-scheduler -n "$NAMESPACE" || true
          kubectl rollout restart deployment/vomeet-google-integration-worker -n "$NAMESPACE" || true
          kubectl rollout restart deployment/vomeet-transcription-collector -n "$NAMESPACE"
          
          echo "â³ Waiting for rollouts to complete..."
          kubectl rollout status deployment/vomeet-admin-api -n "$NAMESPACE" --timeout=120s
          kubectl rollout status deployment/vomeet-api-gateway -n "$NAMESPACE" --timeout=120s
          kubectl rollout status deployment/vomeet-bot-manager -n "$NAMESPACE" --timeout=120s
          kubectl rollout status deployment/vomeet-google-integration -n "$NAMESPACE" --timeout=120s
          kubectl rollout status deployment/vomeet-google-integration-scheduler -n "$NAMESPACE" --timeout=120s || true
          kubectl rollout status deployment/vomeet-google-integration-worker -n "$NAMESPACE" --timeout=120s || true
          kubectl rollout status deployment/vomeet-transcription-collector -n "$NAMESPACE" --timeout=120s
          echo "âœ… All rollouts complete!"

      - name: Run database migrations
        env:
          TAG: ${{ needs.set-environment.outputs.image_tag }}
          NAMESPACE: ${{ needs.set-environment.outputs.namespace }}
        run: |
          echo "ðŸ”„ Running database migrations..."
          
          # Wait for CNPG cluster to be ready
          echo "Waiting for CNPG cluster..."
          kubectl wait --for=condition=Ready clusters.postgresql.cnpg.io/vomeet-cnpg -n "$NAMESPACE" --timeout=120s || true
          
          # Delete any previous migration job
          kubectl delete job db-migrate -n "$NAMESPACE" --ignore-not-found=true
          
          # Create migration job
          cat <<EOF | kubectl apply -f -
          apiVersion: batch/v1
          kind: Job
          metadata:
            name: db-migrate
            namespace: $NAMESPACE
          spec:
            ttlSecondsAfterFinished: 300
            backoffLimit: 3
            template:
              spec:
                restartPolicy: Never
                securityContext:
                  runAsNonRoot: true
                  runAsUser: 1000
                  seccompProfile:
                    type: RuntimeDefault
                containers:
                - name: migrate
                  image: ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-transcription-collector:${TAG}
                  securityContext:
                    allowPrivilegeEscalation: false
                    capabilities:
                      drop:
                        - ALL
                  command:
                  - sh
                  - -c
                  - |
                    set -e
                    echo "Checking database state..."
                    
                    # Check if alembic_version table exists (using sync engine)
                    if python -c "
                    from sqlalchemy import text
                    from shared_models.database import get_engine
                    def check():
                        engine = get_engine()
                        with engine.connect() as conn:
                            result = conn.execute(text(\"SELECT 1 FROM information_schema.tables WHERE table_name='alembic_version'\"))
                            return result.scalar() is not None
                    print('EXISTS' if check() else 'EMPTY')
                    " | grep -q "EXISTS"; then
                      echo "Database is Alembic-managed, running upgrade..."
                      alembic -c /app/alembic.ini upgrade head
                    else
                      echo "Fresh database, initializing schema..."
                      python -c "import asyncio; from shared_models.database import init_db; asyncio.run(init_db())"
                      alembic -c /app/alembic.ini stamp head
                    fi
                    echo "âœ… Migration complete!"
                  env:
                  - name: DB_HOST
                    value: vomeet-cnpg-rw
                  - name: DB_PORT
                    value: "5432"
                  - name: DB_NAME
                    value: vomeet
                  - name: DB_USER
                    value: vomeet
                  - name: DB_PASSWORD
                    valueFrom:
                      secretKeyRef:
                        name: vomeet-db
                        key: password
                  - name: REDIS_HOST
                    value: dragonfly
                  - name: REDIS_PORT
                    value: "6379"
          EOF
          
          # Wait for job to complete
          echo "Waiting for migration job to complete..."
          kubectl wait --for=condition=complete job/db-migrate -n "$NAMESPACE" --timeout=120s
          
          # Show logs
          echo "Migration logs:"
          kubectl logs job/db-migrate -n "$NAMESPACE"
          
          echo "âœ… Database migrations complete!"

      - name: Verify deployment
        env:
          NAMESPACE: ${{ needs.set-environment.outputs.namespace }}
        run: |
          echo "Checking deployments..."
          kubectl get deployments -n "$NAMESPACE"
          echo ""
          echo "Checking pods..."
          kubectl get pods -n "$NAMESPACE"
          echo "âœ… Deployment verified"

      - name: Cleanup kubeconfig
        if: always()
        run: rm -f ~/.kube/config

      - name: Send success notification to Telegram
        if: success()
        env:
          TAG: ${{ needs.set-environment.outputs.image_tag }}
          ENVIRONMENT: ${{ needs.set-environment.outputs.environment }}
          NAMESPACE: ${{ needs.set-environment.outputs.namespace }}
        run: |
          curl -s -X POST "https://api.telegram.org/bot${{ secrets.TELEGRAM_BOT_TOKEN }}/sendMessage" \
            -d chat_id="${{ secrets.TELEGRAM_CHAT_ID }}" \
            -d message_thread_id="${{ secrets.TELEGRAM_THREAD_ID }}" \
            -d text="âœ… *Vomeet Deployed*%0A%0AðŸŒ Environment: $ENVIRONMENT%0AðŸ“¦ Namespace: $NAMESPACE%0AðŸ·ï¸ Image Tag: $TAG%0AðŸ‘¤ Triggered by: ${{ github.actor }}%0Aâ° Time: $(date -u '+%Y-%m-%d %H:%M:%S UTC')%0AðŸ”— [View Run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})" \
            -d parse_mode="Markdown"

      - name: Send failure notification to Telegram
        if: failure()
        env:
          TAG: ${{ needs.set-environment.outputs.image_tag }}
          ENVIRONMENT: ${{ needs.set-environment.outputs.environment }}
        run: |
          curl -s -X POST "https://api.telegram.org/bot${{ secrets.TELEGRAM_BOT_TOKEN }}/sendMessage" \
            -d chat_id="${{ secrets.TELEGRAM_CHAT_ID }}" \
            -d message_thread_id="${{ secrets.TELEGRAM_THREAD_ID }}" \
            -d text="âŒ *Vomeet Deploy Failed*%0A%0AðŸŒ Environment: $ENVIRONMENT%0AðŸ·ï¸ Image Tag: $TAG%0AðŸ‘¤ Triggered by: ${{ github.actor }}%0Aâ° Time: $(date -u '+%Y-%m-%d %H:%M:%S UTC')%0AðŸ”— [View Run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})" \
            -d parse_mode="Markdown"
